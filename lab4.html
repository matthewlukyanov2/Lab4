<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Canvas</title>
    <style type="text/css">
        canvas {
            border: 1px solid grey; 
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
</head>
<body>
    <h1>Matthew</h1>
    <canvas id="canvas-for-ball" width="800" height="400"></canvas>
    <script type="text/javascript">
        class Ball {
            constructor(x, y, radius, xVelocity, yVelocity, rotationSpeed, color = 'red') {
                this.x = x; 
                this.y = y; 
                this.radius = radius; 
                this.xVelocity = xVelocity; 
                this.yVelocity = yVelocity; 
                this.rotationSpeed = rotationSpeed; 
                this.rotationAngle = 0; 
                this.gravity = 0.1; 
                this.color = color;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotationAngle);

                // Draw outer circle
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.stroke();

                // Draw peace sign inner lines
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(0, this.radius);
                ctx.stroke();

                // Left diagonal line
                ctx.beginPath();
                let angle1 = (5 * Math.PI) / 4;
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle1) * this.radius, Math.sin(angle1) * this.radius);
                ctx.stroke();

                // Right diagonal line
                ctx.beginPath();
                let angle2 = (7 * Math.PI) / 4;
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle2) * this.radius, Math.sin(angle2) * this.radius);
                ctx.stroke();

                ctx.restore(); // Restore the original context
            }

            move(canvasWidth, canvasHeight) {
                this.yVelocity += this.gravity;
                this.x += this.xVelocity;
                this.y += this.yVelocity;

                // Collision detection for left/right walls
                if (this.x - this.radius <= 0 || this.x + this.radius >= canvasWidth) {
                    this.xVelocity = -this.xVelocity;
                }

                // Collision detection for top/bottom walls
                if (this.y + this.radius >= canvasHeight) {
                    this.y = canvasHeight - this.radius; 
                    this.yVelocity *= -0.9; // Reverse direction and lose 10% energy on bounce
                } else if (this.y - this.radius <= 0) {
                    this.y = this.radius; 
                    this.yVelocity *= -0.9; 
                }

                // Update the rotation angle
                this.rotationAngle += this.rotationSpeed;
            }

                // Check if the ball contains the given (mouseX, mouseY)
            contains(mouseX, mouseY) {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                return Math.sqrt(dx * dx + dy * dy) < this.radius;
            }
        }

        class Paddle {
            constructor(x, y, radius, speed) {
                this.x = x; 
                this.y = y; 
                this.radius = radius;
                this.speed = speed; 
                this.yVelocity = 0; 
                this.score = 0; 
            }

            draw(ctx) {
                ctx.fillStyle = 'blue'; 
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            move(canvasHeight) {
                this.y += this.yVelocity;

                // Prevent the paddle from going off the canvas (vertically)
                if (this.y < this.radius) this.y = this.radius;
                if (this.y + this.radius > canvasHeight) this.y = canvasHeight - this.radius; 
            }

            updateVelocity(direction) {
                if (direction === 'up') {
                    this.yVelocity = -this.speed; 
                } else if (direction === 'down') {
                    this.yVelocity = this.speed; 
                } else {
                    this.yVelocity = 0; 
                }
            }

            moveTo(y) {
                this.y = y - this.radius; 
            }
        }

        // Set up the canvas and its context
        const canvas = document.getElementById("canvas-for-ball");
        const ctx = canvas.getContext("2d");

        // Create an array to store multiple balls
        let balls = [];

        // Function to add a new random ball to the array
        function addNewBall() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const radius = 20;
            const xVelocity = (Math.random() - 0.5) * 4; // Random horizontal velocity
            const yVelocity = (Math.random() - 0.5) * 4; // Random vertical velocity
            const rotationSpeed = (Math.random() - 0.5) * 0.1; // Random rotation speed
            const color = `hsl(${Math.random() * 360}, 100%, 50%)`; // Random color

            const newBall = new Ball(x, y, radius, xVelocity, yVelocity, rotationSpeed, color);
            balls.push(newBall); // Add the new ball to the array
        }

        // Create a new ball object
        let ball = new Ball(150, 150, 20, 2, 2, 0.05);
        

        // Create new paddle objects
        let paddle1 = new Paddle(50, canvas.height / 2, 25, 5); 
        let paddle2 = new Paddle(740, canvas.height / 2, 25, 5); 

        let collisionMessage = ""; // Variable to hold the collision message
        let messageTimeout; 

        window.addEventListener('keydown', function(event) {
           if (event.key === '+') {
        // Increase both xVelocity and yVelocity by 1 unit
              ball.xVelocity *= 1.1;
              ball.yVelocity *= 1.1;
           } else if (event.key === '-') {
        // Decrease both xVelocity and yVelocity by 1 unit
              ball.xVelocity *= 0.9;
              ball.yVelocity *= 0.9;
           }
        });

        window.addEventListener("keydown", function(event) {
            if (event.key === 'ArrowUp') {
                paddle2.updateVelocity('up'); 
            } else if (event.key === 'ArrowDown') {
                paddle2.updateVelocity('down'); 
            } else if (event.key === 'w') {
                paddle1.updateVelocity('up'); 
            } else if (event.key === 's') {
                paddle1.updateVelocity('down'); 
            }
        });

        window.addEventListener("keyup", function(event) {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                paddle2.updateVelocity('stop'); 
            } else if (event.key === 'w' || event.key === 's') {
                paddle1.updateVelocity('stop'); 
            }
        });

        canvas.addEventListener("mousemove", function(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseY = event.clientY - rect.top; 
            paddle1.moveTo(mouseY); 
        });

        function detectCollision(ball, paddle) {
            let dx = ball.x - paddle.x;
            let dy = ball.y - paddle.y;
            let distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < ball.radius + paddle.radius) {
                // Reverse ball velocity upon collision
                ball.xVelocity = -ball.xVelocity;
                ball.yVelocity = -ball.yVelocity;
                paddle.score++;

                // Set the collision message and clear it after 0.75 seconds
                collisionMessage = "Collision detected!";
                clearTimeout(messageTimeout); // Clear any existing timeout
                messageTimeout = setTimeout(() => {
                    collisionMessage = ""; // Clear the message
                }, 750);
            }
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.xVelocity = 2; // Reset to original speed
            ball.yVelocity = 2; // Reset to original speed
        }

        function drawScores() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Player 1 Score: ${paddle1.score}`, 50, 30);
            ctx.fillText(`Player 2 Score: ${paddle2.score}`, canvas.width - 150, 30);
        }

        function drawCollisionMessage() {
            if (collisionMessage) {
                ctx.fillStyle = 'red';
                ctx.font = '30px Arial';
                ctx.fillText(collisionMessage, canvas.width / 2 - 100, canvas.height / 2);
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Move and draw the ball
            ball.move(canvas.width, canvas.height);
            ball.draw(ctx);

            paddle1.move(canvas.height);
            paddle1.draw(ctx);

            paddle2.move(canvas.height);
            paddle2.draw(ctx);

            // Detect collision between the ball and both paddles
            detectCollision(ball, paddle1);
            detectCollision(ball, paddle2);

            // Check if the ball hits the walls behind paddles
            if (ball.x - ball.radius < paddle1.x) {
                paddle2.score--; 
                resetBall(); // Reset the ball's position
            } else if (ball.x + ball.radius > paddle2.x) {
                paddle1.score--; 
                resetBall(); // Reset the ball's position
            }

            drawScores(); // Draw scores on the canvas
            drawCollisionMessage(); // Draw the collision message

            window.requestAnimationFrame(animate);
        }

        // Start the animation
        animate();
    </script>
</body>
</html>
